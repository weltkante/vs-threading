<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AppliedSynchronizationContextNotAllowed" xml:space="preserve">
    <value>Acquiring locks on threads with a SynchronizationContext applied is not allowed.</value>
  </data>
  <data name="CannotUpgradeNonUpgradeableLock" xml:space="preserve">
    <value>A non-upgradeable read lock is held by the caller and cannot be upgraded.</value>
  </data>
  <data name="DangerousReadLockRequestFromWriteLockFork" xml:space="preserve">
    <value>Dangerous request for read lock from fork of write lock.</value>
  </data>
  <data name="InvalidAfterCompleted" xml:space="preserve">
    <value>Already transitioned to the Completed state.</value>
  </data>
  <data name="InvalidLock" xml:space="preserve">
    <value>This operation can only be executed against a valid lock.</value>
  </data>
  <data name="InvalidWithoutLock" xml:space="preserve">
    <value>A lock is required.</value>
  </data>
  <data name="JoinableTaskContextAndCollectionMismatch" xml:space="preserve">
    <value>JoinableTask does not belong to the context this collection was instantiated with.</value>
  </data>
  <data name="JoinableTaskContextNodeAlreadyRegistered" xml:space="preserve">
    <value>This node already registered.</value>
  </data>
  <data name="LazyValueFaulted" xml:space="preserve">
    <value>Lazily created value faulted during construction.</value>
  </data>
  <data name="LazyValueNotCreated" xml:space="preserve">
    <value>Lazily created value not yet constructed.</value>
  </data>
  <data name="LockCompletionAlreadyRequested" xml:space="preserve">
    <value>This lock has already been marked for completion.  No new top-level locks can be serviced.</value>
  </data>
  <data name="NotAllowedUnderURorWLock" xml:space="preserve">
    <value>This operation is not allowed while holding an active upgradeable read or write lock from an AsyncReaderWriterLock.</value>
  </data>
  <data name="QueueEmpty" xml:space="preserve">
    <value>The queue is empty.</value>
  </data>
  <data name="SemaphoreMisused" xml:space="preserve">
    <value>This semaphore has been misused and can no longer be used.</value>
  </data>
  <data name="SemaphoreStackNestingViolated" xml:space="preserve">
    <value>Nested semaphore requests must be released in LIFO order when the reentrancy setting is: '{0}'</value>
  </data>
  <data name="STAThreadCallerNotAllowed" xml:space="preserve">
    <value>This operation cannot be completed on an STA thread.</value>
  </data>
  <data name="SwitchToMainThreadFailedToReachExpectedThread" xml:space="preserve">
    <value>An attempt to switch to the main thread failed to reach the expected thread. Was the JoinableTaskContext initialized on the wrong thread or with a SynchronizationContext whose Post method does not execute its delegate on the main thread?</value>
    <comment>An error displayed when there is a serious programming fault with an application. It will usually be thrown early in development in the application and is not expected to be seen by an end user.</comment>
  </data>
  <data name="ValueFactoryReentrancy" xml:space="preserve">
    <value>The value factory has called for the value on the same instance.</value>
  </data>
  <data name="FrameMustBePushedFirst" xml:space="preserve">
    <value>This instance must be pushed first.</value>
  </data>
  <data name="PushFromWrongThread" xml:space="preserve">
    <value>Message pump can only be run from the original thread.</value>
  </data>
  <data name="SyncContextFrameMismatchedAffinity" xml:space="preserve">
    <value>This frame has already been used with a different instance.</value>
  </data>
  <data name="SemaphoreAlreadyHeld" xml:space="preserve">
    <value>Semaphore is already held and reentrancy setting is '{0}'.</value>
  </data>
  <data name="WriteLockOutlived" xml:space="preserve">
    <value>Write lock out-lived by a nested read lock, which is not allowed.</value>
  </data>
  <data name="MultipleContinuationsNotSupported" xml:space="preserve">
    <value>Multiple continuations are not supported.</value>
  </data>
  <data name="SyncContextNotSet" xml:space="preserve">
    <value>No SynchronizationContext to reach the main thread has been set.</value>
  </data>
</root>